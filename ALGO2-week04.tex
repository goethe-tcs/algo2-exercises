% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo221}
\uebung{4}{}{}
\blattname{Übungen zu Woche 4: Amortisierte Analyse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

Das Übungsblatt enthält alle empfohlenen Lernaktivitäten für die aktuelle Woche.

\begin{itemize}
\item \textbf{Heimarbeit bis Montag 17:00.}
    \begin{itemize}
    \item 
    Schau die Videos an und lies die Buchkapitel.
    \item Bearbeite die \emoji{seedling}-Aufgabe in \href{https://moodle.studiumdigitale.uni-frankfurt.de/moodle/course/view.php?id=2241}{Moodle}. (Feste Abgabefrist!)
    \item Lese den Aufgabentext aller Übungsaufgaben.
    \end{itemize}
\item \textbf{Heimarbeit.} Bearbeite die Übungsaufgaben soweit möglich. Probier zumindest alle mal!
\item \textbf{Dienstag/Donnerstag.}
\begin{itemize}
    \item \textbf{8:00--8:15.} Besprechung im Hörsaal.
    \item \textbf{8:15--9:15.} Bearbeite jetzt die Übungen, die du noch nicht lösen konntest. Sprich mit anderen Studis! Frag das Vorlesungsteam um Hilfe!
    \item \textbf{9:15--9:45.} Lösungsspaziergang zu den Aufgaben für heute.
\end{itemize}

\item \textbf{Heimarbeit bis Freitag, den 12.11., 17:00.} Gib deine Lösungen zu der \emoji{star}-Aufgabe von diesem Übungsblatt in \href{https://moodle.studiumdigitale.uni-frankfurt.de/moodle/course/view.php?id=2241}{Moodle} ab. (Feste Abgabefrist!)
\end{itemize}

\section*{Dienstag}

\begin{aufgabe}[Splay-Bäume]
	% Algorithms and Data Structures 2 - amortized.pdf
	Gegeben sei ein leerer Splay-Baum.
	\begin{enumerate}
		\item Füge die Schlüssel $41,38,31,12,19,8$ in der angegebenen Reihenfolge ein. Wie sieht der resultierende Splay-Baum aus?
		\item Wie sieht der Splay-Baum aus, nachdem man Schlüssel $31$ entfernt hat?
	\end{enumerate}		
\end{aufgabe}

\begin{aufgabe}[Amortisierte Analyse]
	% Algorithms and Data Structures 2 - amortized.pdf
	Wir haben eine Datenstruktur, bei der die Kosten $T(i)$ der $i$-ten Operation durch 
	$$T(i) = \begin{cases} 2i & \text{falls i eine 2er Potenz ist}, \\ 1 & \text{sonst} \end{cases}$$ 
	gegeben sind.
	Was ist die amortisierte Laufzeit dieser Operation? Benutze sowohl die Aggregationsmethode, als auch das Buchhalter-Argument (\textit{accounting method}), um die amortisierte Laufzeit zu analysieren.
\end{aufgabe}    

\begin{aufgabe}[Potenzialfunktion: Verdopplung von Arrays]
	% Algorithms and Data Structures 2 - amortized.pdf
	Gegeben sei eine dynamischen Tabelle, die nur Einfügungen und keine Löschungen erlaubt, und für die die Verdopplungsmethode genutzet wird. Wenn wir als Potenzialfunktion $\Phi(D_i) = k$ für $k$ ist die Anzahl an Elementen im Array wählen, können wir dann zeigen, dass die amortisierten Kosten einer Einfügung $\Oh(1)$ betragen?
\end{aufgabe}

\begin{aufgabe}[Mengenvereinigung]
	% Algorithms and Data Structures 2 - amortized.pdf
	Im Mengenvereinigungsproblem betrachten wir $n$ Elemente, die zu Beginn in $n$ einzelne Sets aufgeteilt sind. Wir wollen die folgenden Operationen ausführen können:
	\begin{itemize}
		\item \emph{Union($A,B$)}: Führe die beiden Menge $A$ und $B$ zu einer neuen Menge $C = A \cup B$ zusammen und lösche die alten Mengen.
		\item \emph{SameSet($x,y$)}: Gebe \textit{true} zurück, wenn $x$ und $y$ in der selben Menge liegen, ansonsten gebe \textit{false} zurück.
	\end{itemize}
	Das können wir implementieren, indem man jeder Menge am Anfang eine Farbe zuweist. Beim Zusammenführen zweier Mengen übernimmt die kleinere Menge die Farbe der größeren Menge; bei Gleichstand wird eine der beiden Farben beliebig gewählt. Um zu überprüfen, dass zwei Elemente in der gleichen Menge liegen, vergleicht man ihre Farben.
	\begin{enumerate}
		\item Analysiere die Kosten der beiden Operationen im \textit{worst-case}.
		\item Zeige, dass die amortisierten Kosten $\Oh(\log n)$ für \emph{Union} und $\O(1)$ für \emph{SameSet} betragen. Zeige ebenfalls, dass jede Sequenz von $m$ Union-Operationen und $l$ SameSet-Operationen die Laufzeit $\Oh(m \log n + l)$ benötigt.
		\item[] \textit{Hinweis:} Wie oft kann ein Element die Farbe wechseln?
	\end{enumerate}
\end{aufgabe}

\section*{Donnerstag}

\begin{aufgabe}[Splay-Bäume]
	% Algorithms and Data Structures 2 - amortized.pdf
	Professor Sheldon schlägt die sogenannten Spiel-Bäume als eine einfachere Variante der Splay-Bäume vor. Im Gegensatz zu Splay-Bäumen führen sie in der Splay-Operation nur eine Rotation aus. 
	\begin{enumerate}
		\item Was sind die amortisierten Kosten der Operation \emph{splay($x$)}, wenn wir nur einzelne Rotationen benutzen? Analysiere die Kosten mit der selben Potenzialfunktion, die wir für Splay-Bäume verwendet haben.
		\item Was sind die gesamten (tatsächlichen) Kosten, wenn man zuerst $n$ Elemente mit den Schlüsseln $1,2,3,\dots,n$ der Reihenfolge nach in einen Spiel-Baum einfügt und dann in der gleichen Reihenfolge sucht?
		\item Professor Sheldon behauptet, dass das Einfügen, Suchen und Löschen in Spiel-Bäumen amortisierte Kosten von $\Oh(\log n)$ hat. \glqq Du musst nur eine raffiniertere Potenzialfunktion benutzen\grqq{,} sagt er. Liegt er damit richtig?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Implementierung von dynamischen Tabellen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Implementiere deine eigene dynamische Tabelle für \texttt{Integer}-Werte, ohne dabei built-in Methoden zu verwenden. Deine dynamische Tabelle soll folgende Operationen beherrschen:
	\begin{itemize}
		\item Einfügen von Elementen,
		\item Löschen von Elementen,
		\item Ausgabe enthaltener Elemente,
		\item Ausgabe der Größe der Tabelle.
	\end{itemize}
\end{aufgabe}

\begin{aufgabe}[Dynamische Hashtabelle]
	% Algorithms and Data Structures 2 - amortized.pdf
	Erkläre, wie man eine dynamische Hashtabelle mit Einfügungen unter Verwendung der Verdopplungsmethode erstellt. Deine Lösung soll einen Speicherplatz von $\Theta(n)$ benutzen, wobei $n$ die Anzahl der Elemente in der Hashtabelle ist. Wie viel Zeit benötigt deine Lösung zum Einfügen eines Elements in die Hashtabelle?
\end{aufgabe}

\begin{aufgabe}[Deamortisierung von Hashtabellen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Manchmal ist es möglich, Datenstrukturen zu deamortisieren, d.h. man erhält die selben \emph{worst-case} Schranken, wie im amortisierten Fall, indem die Arbeit \glqq im Hintergrund\grqq{}  ausgeführt wird. Sei $n$ ist die aktuelle Anzahl der Elemente in der Tabelle. Zeige, dass man beim Einfügen eines Elements in die dynamische Tabelle im \emph{worst-case} einen konstanten Zeitaufwand benötigt, während man immer noch $\Oh(n)$ Speicherplatz benutzt.
	
	\textit{Hinweis:} Benutze die Verdopplungsmethode, aber verteile die Arbeit auf alle Einfügungen.
\end{aufgabe}

\begin{aufgabe}[Puzzle der Woche: Prinzessinnen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Stelle dir vor, du bist ein junger Prinz aus dem fernen Lande Algo und der König des benachbarten Landes Logik hat 3 Töchter. Die Älteste erzählt immer die Wahrheit, die Jüngste lügt immer und die Mittlere lügt und sagt die Wahrheit, wie es ihr gefällt.
	
	Du willst entweder die älteste oder die jüngste Tochter heiraten, da immer lügen genauso gut ist, wie immer die Wahrheit zu sagen. Nur die mittlere Tochter möchtest du nicht heiraten. Allerdings sehen alle Töchter gleich aus, sodass du sie nicht unterscheiden kannst.

	Der König ist ein hinterhältiger Mann und erlaubt dir, genau \textit{eine} Frage an genau \textit{eine} der drei Töchter zu stellen. Diese Frage soll mit \glqq Ja\grqq{} oder \glqq Nein\grqq{} zu beantworten sein. Danach musst du dich entscheiden, welche der drei Prinzessinnen du heiraten möchtest. 

	Welche Frage sollst du stellen und welche der Töchter sollst du aussuchen?
\end{aufgabe}

\section*{Sternaufgabe}

\begin{aufgabe}[\emoji{star}: Der Unterschied zwischen Stacks und Queues]

	Man kann eine Queue mithilfe von zwei Stacks und $\Oh(1)$ zusätzlichen Speicherplatz implementieren. 
	Der \textit{einzige} Zugriff auf die Stacks erfolgt durch die zwei Standardoperationen \texttt{PUSH} und \texttt{POP}.
	Beschreibe eine Queue Implementierung, sodass die amortisierte Laufzeit für jede \texttt{enqueue} oder \texttt{dequeue} Operation $\Oh(1)$ beträgt. 

\end{aufgabe}

\end{document}
