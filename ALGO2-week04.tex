% !TeX spellcheck = de_DE
\documentclass{uebung_cs}
\usepackage{algo221}
\uebung{4}{}{}
\blattname{Übungen zu Woche 4: Amortisierte Analyse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

Das Übungsblatt enthält alle empfohlenen Lernaktivitäten für die aktuelle Woche.

\begin{itemize}
\item \textbf{Heimarbeit bis Montag 17:00.}
    \begin{itemize}
    \item 
    Schau die Videos an und lies die Buchkapitel.
    \item Bearbeite die \emoji{seedling}-Aufgabe in \href{https://moodle.studiumdigitale.uni-frankfurt.de/moodle/course/view.php?id=2241}{Moodle}. (Feste Abgabefrist!)
    \item Lese den Aufgabentext aller Übungsaufgaben.
    \end{itemize}
\item \textbf{Heimarbeit.} Bearbeite die Übungsaufgaben soweit möglich. Probier zumindest alle mal!
\item \textbf{Dienstag/Donnerstag.}
\begin{itemize}
    \item \textbf{8:00--8:15.} Besprechung im Hörsaal.
    \item \textbf{8:15--9:15.} Bearbeite jetzt die Übungen, die du noch nicht lösen konntest. Sprich mit anderen Studis! Frag das Vorlesungsteam um Hilfe!
    \item \textbf{9:15--9:45.} Lösungsspaziergang zu den Aufgaben für heute.
\end{itemize}

\item \textbf{Heimarbeit bis Freitag, den 12.11., 17:00.} Gib deine Lösungen zu der \emoji{star}-Aufgabe von diesem Übungsblatt in \href{https://moodle.studiumdigitale.uni-frankfurt.de/moodle/course/view.php?id=2241}{Moodle} ab. (Feste Abgabefrist!)
\end{itemize}

\section*{Dienstag}

\begin{aufgabe}[Splay-Bäume]
	% Algorithms and Data Structures 2 - amortized.pdf
	Gegeben sei ein leerer Splay-Baum.
	\begin{enumerate}
		\item Füge die Schlüssel $41,38,31,12,19,8$ in der angegebenen Reihenfolge ein. Wie sieht der resultierende Splay-Baum aus?
		\item Wie sieht der Splay-Baum aus, nachdem man Schlüssel $31$ entfernt hat?
	\end{enumerate}		
\end{aufgabe}

\begin{aufgabe}[Amortisierte Analyse]
	% Algorithms and Data Structures 2 - amortized.pdf
	Wir haben eine Datenstruktur mit einer Operation \texttt{Foo()}. Die Kosten~$T(i)$ der $i$-ten Ausführung dieser Operation sind gegeben durch: 
	\[T(i) = \begin{cases} 2i & \text{falls i eine Zweierpotenz ist}, \\ 1 & \text{sonst}. \end{cases}\] 
	Was ist die amortisierte Laufzeit der Operation \texttt{Foo()}? Benutze sowohl die Aggregationsmethode, als auch das Buchhalter-Argument (\textit{accounting method}), um die amortisierte Laufzeit zu analysieren.
\end{aufgabe}    

\begin{aufgabe}[Potenzialfunktion: Verdopplung von Arrays]
	% Algorithms and Data Structures 2 - amortized.pdf
	Gegeben sei eine dynamische Tabelle, die nur Einfügungen und keine Löschungen erlaubt, und für die die Verdopplungsmethode genutzt wird. Wenn wir als Potenzialfunktion $\Phi(D_i) = k$ wählen, wobei $k$ die Anzahl an Elementen im Array ist, können wir dann mit dieser Potenzialfunktion zeigen, dass die amortisierten Kosten einer Einfügung $\Oh(1)$ sind?
\end{aufgabe}

\begin{aufgabe}[Mengenvereinigung]
	% Algorithms and Data Structures 2 - amortized.pdf
	Mengenvereinigung ist eine abstrakte Datenstruktur, die disjunkte Teilmengen von $\{1,\dots,n\}$ verwaltet (ganz ähnlich zu Union-Find).
	Anfangs sind die Elemente auf $n$ einzelne Mengen aufgeteilt, also $\{1\}, \{2\}, \dots,\{n\}$.
	Die Datenstruktur soll die folgenden Operationen unterstützen:
	\begin{itemize}
		\item Union($A,B$): Führe die beiden Mengen $A$ und $B$ zu einer neuen Menge $C = A \cup B$ zusammen und lösche die alten Mengen.
		\item SameSet($x,y$): Gebe \textit{true} zurück, wenn $x$ und $y$ in derselben Menge liegen, ansonsten gebe \textit{false} zurück.
	\end{itemize}
	Diese Operationen können wir folgendermaßen implementieren: Weise jeder Menge am Anfang eine eigene Farbe zu. Um die Union-Operation zu unterstützen, übernimm für alle Elemente in der kleineren Menge die Farbe der größeren Menge (bei Gleichstand wird eine der beiden Farben beliebig gewählt). Um die SameSet-Operation zu beantworten, überprüfe, ob die zwei Elemente dieselbe Farbe haben.
	
	\begin{enumerate}
		\item Analysiere die \textit{worst-case} Laufzeit der beiden Operationen.
		\item Zeige, dass die amortisierten Kosten $\Oh(\log n)$ für Union und $\O(1)$ für SameSet betragen. Zeige ebenfalls, dass jede Sequenz von $m$ Union-Operationen und $l$ SameSet-Operationen die worst-case Laufzeit $\Oh(m \log n + l)$ einhält.
		\item[] \textit{Hinweis:} Wie oft kann ein Element die Farbe wechseln?
	\end{enumerate}
\end{aufgabe}

\section*{Donnerstag}

\begin{aufgabe}[Splay-Bäume]
	% Algorithms and Data Structures 2 - amortized.pdf
	Professor Sheldon schlägt die sogenannten Spiel-Bäume als eine einfachere Variante der Splay-Bäume vor. Hierbei verzichten wir innerhalb der \emph{splay(x)}-Methode auf die nervigen \emph{roller-coaster} und \emph{zig-zag} Transformationen, und führen stattdessen nur einfache Rotationen durch---so lange, bis $x$ an der Wurzel landet.
	\begin{enumerate}
		\item Was sind die amortisierten Kosten der Operation \emph{splay($x$)}, wenn wir nur einfache Rotationen benutzen? Analysiere die Kosten mit derselben Potenzialfunktion, die wir für Splay-Bäume verwendet haben.
		\item Was sind die gesamten (tatsächlichen) Kosten, wenn man zuerst $n$ Elemente mit den Schlüsseln $1,2,3,\dots,n$ der Reihenfolge nach in einen Spiel-Baum einfügt und dann in der gleichen Reihenfolge sucht?
		\item Professor Sheldon behauptet, dass das Einfügen, Suchen und Löschen in Spiel-Bäumen amortisierte Kosten von $\Oh(\log n)$ hat. \enquote{Du musst nur eine raffiniertere Potenzialfunktion benutzen}, sagt er. Liegt er damit richtig?
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Implementierung von dynamischen Tabellen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Implementiere deine eigene dynamische Tabelle für \texttt{Integer}-Werte, ohne dabei built-in Methoden zu verwenden. Deine dynamische Tabelle soll folgende Operationen beherrschen:
	\begin{itemize}
		\item Einfügen von Elementen,
		\item Löschen von Elementen,
		\item Ausgabe enthaltener Elemente,
		\item Ausgabe der Größe der Tabelle.
	\end{itemize}
\end{aufgabe}

\begin{aufgabe}[Dynamische Hashtabelle]
	% Algorithms and Data Structures 2 - amortized.pdf
	Erkläre, wie man eine dynamische Hashtabelle mit Einfügungen unter Verwendung der Verdopplungsmethode verwaltet. Deine Lösung soll einen Speicherplatz von $\Theta(n)$ benutzen, wobei $n$ die Anzahl der Elemente in der Hashtabelle ist. Wie viel Zeit benötigt deine Lösung zum Einfügen eines Elements in die Hashtabelle?
\end{aufgabe}

\begin{aufgabe}[Deamortisierung von dynamischen Tabellen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Manchmal ist es möglich, Datenstrukturen zu deamortisieren. Das heißt, man erhält dieselben \emph{worst-case} Schranken, wie im amortisierten Fall, indem die teure Arbeit auf viele Operationen verteilt wird und im Hintergrund ausgeführt wird.

	\begin{enumerate}
		\item
	Zeige, wie man dynamische Tabellen mit Einfügen (ohne Löschen) so implementieren kann, dass das Einfügen eines Elements im \emph{worst-case} einen konstanten Zeitaufwand benötigt. Hierbei soll zu jedem Zeitpunkt weiterhin nur $\Oh(n)$ Speicherplatz benutzt werden, wo $n$ die Anzahl der gespeicherten Elemente ist.
	
	\item[]
	\textit{Hinweis:} Benutze die Verdopplungsmethode, aber verteile die Arbeit auf alle Einfügungen.

	\item Jetzt mach dasselbe für dynamische Tabellen mit Einfügen \emph{und} Löschen.
	\end{enumerate}
\end{aufgabe}

\begin{aufgabe}[Puzzle der Woche: Prinzessinnen]
	% Algorithms and Data Structures 2 - amortized.pdf
	Stelle dir vor, du bist ein junger Prinz aus dem fernen Lande Algo und der König des benachbarten Landes Logik hat 3 Töchter. Die Älteste erzählt immer die Wahrheit, die Jüngste lügt immer und die Mittlere lügt und sagt die Wahrheit, wie es ihr gefällt.
	
	Du willst entweder die älteste oder die jüngste Tochter heiraten, da immer lügen genauso gut ist, wie immer die Wahrheit zu sagen. Nur die mittlere Tochter möchtest du nicht heiraten. Allerdings sehen alle Töchter gleich aus, sodass du sie nicht unterscheiden kannst.

	Der König ist ein hinterhältiger Mann und erlaubt dir, genau \textit{eine} Frage an genau \textit{eine} der drei Töchter zu stellen. Diese Frage soll mit \glqq Ja\grqq{} oder \glqq Nein\grqq{} zu beantworten sein. Danach musst du dich entscheiden, welche der drei Prinzessinnen du heiraten möchtest. 

	Welche Frage solltest du stellen und dann welche der Töchter aussuchen?
\end{aufgabe}

\section*{Sternaufgabe}

\begin{aufgabe}[\emoji{star}: Queues mit zwei Stacks]\mbox{}\\
	Wir erinnern uns, dass ein Stack \texttt{S} eine Datenstruktur ist, die die Operationen \texttt{S.PUSH(x)}, \texttt{S.POP()} und \texttt{S.ISEMPTY()} unterstützt. Wir nehmen an, dass diese Operationen in konstanter \emph{worst-case} Zeit implementiert worden sind.

	Du sollst für diese Aufgabe eine Queue \texttt{Q} mithilfe von zwei Stacks \texttt{S1}, \texttt{S2} implementieren. Dabei darfst du nur $\Oh(1)$ zusätzlichen Speicher benutzen.
	Der \textit{einzige} Zugriff auf die Stacks erfolgt als \emph{black-box} über die Standardoperationen \texttt{PUSH}, \texttt{POP} und \texttt{ISEMPTY}.
	\begin{enumerate}
		\item 
		\textbf{Beschreibe mit Pseudocode} eine solche Queue-Implementierung, wobei die amortisierte worst-case Laufzeit für jede \texttt{Q.ENQUEUE(x)}, \texttt{Q.DEQUEUE()} und \texttt{Q.ISEMPTY()} Operation konstant sein muss.
		\item
		\textbf{Beweise mithilfe der Potenzialmethode}, dass die amortisierten Kosten deiner Implementierung tatsächlich konstant sind.
	\end{enumerate}
\end{aufgabe}

\end{document}
